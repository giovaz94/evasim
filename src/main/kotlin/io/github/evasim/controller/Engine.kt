package io.github.evasim.controller

import io.github.evasim.utils.logger
import java.util.concurrent.atomic.AtomicReference
import kotlin.time.DurationUnit
import kotlin.time.toDuration

/**
 * Represents a contract for an engine that provides a sequence of operations
 * such as starting, stopping, handling input, processing events, updating state,
 * and rendering output.
 */
interface Engine {

    /**
     * Defines the target number of frames per second that the engine aims to maintain
     * during execution. This value can influence the smoothness and responsiveness
     * of the engine's simulation and rendering processes.
     */
    val targetFps: Int

    /**
     * Start the engine.
     */
    fun start()

    /**
     * Stop the engine.
     */
    fun stop()

    /**
     * Handle inputs from user.
     */
    fun handleInput()

    /**
     * Handle events generated by other processes.
     */
    fun handleEvents()

    /**
     * Update the simulation state.
     */
    fun update(deltaTime: Double)

    /**
     * Render the new view.
     */
    fun render()
}

/**
 * The SimulationEngine class is responsible for managing and executing the main simulation loop.
 * It runs at a targeted frames-per-second (FPS) and provides methods to handle user input,
 * process events, update simulation state, and render graphics.
 *
 * @property controller The simulation controller instance.
 * @property targetFps The target frames per second the engine aims to maintain.
 */
class SimulationEngine(
    private val controller: Controller,
    override val targetFps: Int = 60,
) : Engine {

    private val running = AtomicReference(false)
    private val timePerFrame = UPDATE_TIMEOUT / targetFps

    override fun start() {
        running.set(true)
        var lastTime = System.nanoTime()
        while (running.get()) {
            val now = System.nanoTime()
            val deltaTime = (now - lastTime) / UPDATE_TIMEOUT.toDouble()
            lastTime = now
            handleInput()
            handleEvents()
            update(deltaTime)
            render()
            val elapsedTime = System.nanoTime() - now
            val sleepTime = (timePerFrame - elapsedTime) / SECOND_TIMEOUT
            if (sleepTime > 0) {
                Thread.sleep(sleepTime)
            } else {
                logger.warning {
                    """
                        Frame overrun detected: frame took ${elapsedTime / SECOND_TIMEOUT}ms, but taget frame time is ${timePerFrame / SECOND_TIMEOUT}ms.
                        Loop cannot keep up with the target FPS of $targetFps -- consider optimizing heavy operations.
                    """.trimIndent()
                }
            }
        }
    }

    override fun stop() {
        running.set(false)
    }

    override fun handleInput() {
        // TODO: handling inputs
    }

    override fun handleEvents() {
        // TODO: handling events
    }

    override fun update(deltaTime: Double) {
        controller.updateDomain(deltaTime.toDuration(DurationUnit.SECONDS))
    }

    override fun render() {
        controller.render()
    }

    private companion object {
        private const val UPDATE_TIMEOUT = 1_000_000_000L
        private const val SECOND_TIMEOUT = 1_000_000
    }
}
