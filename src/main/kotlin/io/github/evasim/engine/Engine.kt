package io.github.evasim.engine

/**
 * Represents a contract for an engine that provides a sequence of operations
 * such as starting, stopping, handling input, processing events, updating state,
 * and rendering output.
 */
interface Engine {
    /**
     * Start the engine.
     */
    fun start(): Unit

    /**
     * Stop the engine.
     */
    fun stop(): Unit

    /**
     * Handle inputs from user.
     */
    fun handleInput(): Unit

    /**
     * Handle events generated by other processes.
     */
    fun handleEvents(): Unit

    /**
     * Update the simulation state.
     */
    fun update(deltaTime: Double): Unit

    /**
     * Render the new view.
     */
    fun render(): Unit
}

/**
 * The SimulationEngine class is responsible for managing and executing the main simulation loop.
 * It runs at a targeted frames-per-second (FPS) and provides methods to handle user input,
 * process events, update simulation state, and render graphics.
 *
 * The class implements the Engine interface, ensuring methods for starting, stopping,
 * handling input, processing events, updating the simulation, and rendering are defined.
 *
 * @property running Indicates whether the simulation engine is currently running.
 * @property targetFps The target frames per second the engine aims to maintain.
 * @property timePerFrame The time allocated for each frame in nanoseconds.
 */
class SimulationEngine(targetFps: Int = 60) : Engine {

    private var running: Boolean = false
    private val timePerFrame = UPDATE_TIMEOUT / targetFps

    override fun start() {
        running = true

        var lastTime = System.nanoTime()
        while (running) {
            val now = System.nanoTime()
            val deltaTime = now - lastTime / UPDATE_TIMEOUT.toDouble()
            lastTime = now

            handleInput()
            handleEvents()
            update(deltaTime)
            render()

            val elapsedTime = System.nanoTime() - now
            val sleepTime = (timePerFrame - elapsedTime) / SECOND_TIMEOUT
            if (sleepTime > 0) {
                Thread.sleep(sleepTime)
            }
        }
    }

    override fun stop() {
        running = false
    }

    override fun handleInput() {
        println("Handling input...")
    }

    override fun handleEvents() {
        println("Handling events...")
    }

    override fun update(deltaTime: Double) {
        println("Delta time: $deltaTime")
    }

    override fun render() {
        println("Rendering...")
    }

    /**
     * Contains constants used for timing configurations within the simulation engine.
     *
     * @property UPDATE_TIMEOUT Represents the total time in nanoseconds allocated for one update cycle.
     * @property SECOND_TIMEOUT Represents the equivalent of one second in microseconds.
     */
    companion object {
        private const val UPDATE_TIMEOUT = 1_000_000_000L
        private const val SECOND_TIMEOUT = 1_000_000
    }
}
