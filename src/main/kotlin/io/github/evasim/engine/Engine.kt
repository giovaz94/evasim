package io.github.evasim.engine

import io.github.evasim.controller.Controller
import kotlin.time.DurationUnit
import kotlin.time.toDuration

/**
 * Represents a contract for an engine that provides a sequence of operations
 * such as starting, stopping, handling input, processing events, updating state,
 * and rendering output.
 */
interface Engine {

    /**
     * Defines the target number of frames per second that the engine aims to maintain
     * during execution. This value can influence the smoothness and responsiveness
     * of the engine's simulation and rendering processes.
     */
    val targetFps: Int

    /**
     * Provides access to the controller responsible for handling user inputs,
     * managing events, updating domain state, and rendering within the engine.
     *
     * The `controller` acts as a central interface for coordinating input processing,
     * event management, state updates, and rendering operations. It plays a key role
     * in ensuring the engine's behavior aligns with the user's actions and the system's
     * intended functionality.
     */
    val controller: Controller

    /**
     * Start the engine.
     */
    fun start()

    /**
     * Stop the engine.
     */
    fun stop()

    /**
     * Handle inputs from user.
     */
    fun handleInput()

    /**
     * Handle events generated by other processes.
     */
    fun handleEvents()

    /**
     * Update the simulation state.
     */
    fun update(deltaTime: Double)

    /**
     * Render the new view.
     */
    fun render()
}

/**
 * The SimulationEngine class is responsible for managing and executing the main simulation loop.
 * It runs at a targeted frames-per-second (FPS) and provides methods to handle user input,
 * process events, update simulation state, and render graphics.
 *
 * The class implements the Engine interface, ensuring methods for starting, stopping,
 * handling input, processing events, updating the simulation, and rendering are defined.
 *
 * @property running Indicates whether the simulation engine is currently running.
 * @property targetFps The target frames per second the engine aims to maintain.
 * @property timePerFrame The time allocated for each frame in nanoseconds.
 */
class SimulationEngine(
    override val controller: Controller,
    override val targetFps: Int = 30,
) : Engine {

    private var running: Boolean = false
    private val timePerFrame = UPDATE_TIMEOUT / targetFps

    override fun start() {
        running = true

        var lastTime = System.nanoTime()
        while (running) {
            val now = System.nanoTime()
            val deltaTime = (now - lastTime) / UPDATE_TIMEOUT.toDouble()
            lastTime = now

            handleInput()
            handleEvents()
            update(deltaTime)
            render()

            val elapsedTime = System.nanoTime() - now
            val sleepTime = (timePerFrame - elapsedTime) / SECOND_TIMEOUT
            println("Sleep for $sleepTime ms")
            if (sleepTime > 0) {
                Thread.sleep(sleepTime)
            }
        }
    }

    override fun stop() {
        running = false
    }

    override fun handleInput() {
        println("Handling input...")
    }

    override fun handleEvents() {
        println("Handling events...")
    }

    override fun update(deltaTime: Double) {
        controller.updateDomain(deltaTime.toDuration(DurationUnit.SECONDS))
    }

    override fun render() {
        controller.render()
    }

    /**
     * Contains constants used for timing configurations within the simulation engine.
     *
     * @property UPDATE_TIMEOUT Represents the total time in nanoseconds allocated for one update cycle.
     * @property SECOND_TIMEOUT Represents the equivalent of one second in microseconds.
     */
    companion object {
        private const val UPDATE_TIMEOUT = 1_000_000_000L
        private const val SECOND_TIMEOUT = 1_000_000
    }
}
